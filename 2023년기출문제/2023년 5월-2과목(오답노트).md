## 2023년 5월 기출문제

#### 31. 명세 기반 테스트 중 올바른 테스트 기법
> - Equivalence Partitioning Testing(동시 분할 검사)
>   - `프로그램의 입력 조건에 중점`을 두고, 어느 하나의 입력 조건에 대하여 타당한 값과 그렇지 못한 값을 설정하여 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 테스트 기법
>   - 경험과 필요에 따라 하나 이상의 값을 선정하여 TC를 작성하는 경우, 결과적으로 보장성은 동일
>   - 명세에 있는 입/출력 값을 활용하기 때문에 명세기반 테스트 기법임(구조기반, 경험기반 기법도 적용 가능)
> - Cause-Effect Graph Testing(원인-결과 그래프 검사)
>   - 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
> - Boundary Value Analysis(경계값 분석)
>   - 입력 자료에만 치중한 동치 분할 기법을 보완하기 위한 기법. 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법
> - Comparison Testing(비교 검사)
>   - 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법

#### 32. 내·외부 모듈 간 인터페이스 데이터 표준을 확인하는데 사용되는 정보
> - 인터페이스 데이터 표준은 `인터페이스 기능`과 `데이터 인터페이스`를 통해 확인할 수 있음

#### 34. 다음 설명하는 정렬(Sort)
> 틀린 문제 : 퀵 정렬에 대한 설명
> - **퀵 정렬(Quick Sort)**
>   - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법
>   - 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬
>   - 피봇(pivot)을 사용하며, 회악의 경우 n(n-1)/2회의 비교를 수행해야함

> #### 정렬(sort)의 종류
> ###### 1. 삽입 정렬(Insertion Sort)
>   -  삽입 정렬은 가장 간단한 정렬 방식으로 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬함
>   -  평균과 최악 모두 수행 시간 복잡도는 O(n^2)
> ###### 2. 쉘 정렬(Shell Sort)
>   - 삽입 정렬을 확장한 개념으로 입력 파일을 어떤 매개변수(h)의 값으로 서브파일을 구성하고, 각 서브파일을 삽입 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식
>   - 평균 수행 시간 복잡도는 O(n^1.5)이고, 최악의 수행 시간 복잡도는 O(n^2)
> ###### 3. 선택 정렬(Selection Sort)
>   - n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식
>   - 평균과 최악 모두 수행 시간 복잡도는 O(n^2)
> ###### 4. 버블 정렬(Bubble Sort)
>   - 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식
>   - 계속 정렬 여부를 플래그 비트(f)로 결정
>   - 평균과 최악 모두 수행 시간 복잡도는 O(n^2)
> ###### 5. 퀵 정렬(Quick Sort)
>   - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는 방식으로 정렬함
>   - 위치에 관계없이 임의의 키를 분할 원소로 사용할 수 있음
>   - 정렬 방식 중에서 가장 빠른 방식
>   - 프로그램에서 되부름을 이용하기 때문에 스택(Stack)이 필요
>   - 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬
>      - 분할(Divide): 기준값인 피봇(Pivot)을 중심으로 정렬할 자료들을 2개의 부분집합으로 나눔
>      - 정복(Conquer): 부분집합의 원소들 중 피봇(Pivot)보다 작은 원소들은 왼쪽, 피봇(Pivot)보다 큰 원소들은 오른쪽 부분집합으로 정렬
>      - 부분집합의 크기가 더 이상 나누어질 수 없을 때까지 분할과 정복을 반복 수행
>   - 평균 수행 시간 복잡도는 O(nlog2n)이고, 최악의 수행 시간 복잡도는 O(n^2)
> ###### 6. 힙 정렬(Heap Sort)
>   - 큰 키(우선 순위)에 자주 액세스하거나 키(우선 순위) 중심으로 정렬된 시퀀스를 활용해야 할 때 유용한 자료구조
>   - 완전이진트리(전이진 트리, complete binary tree)를 이용한 정렬 방식
>   - 평균과 최악 모두 시간 복잡도는 O(nlog2n) 
> ###### 7. 2-Way 합병 정렬(Merge Sort)
>   - 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식
>   - 평균과 최악 모두 시간 복잡도는 O(nlog2n)
> ###### 8. 기수 정렬(Radix Sort, Bucket Sort)
>   - Queue를 이용하여 자릿수(Digit)별로 정렬하는 방식.
>   - 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬함.
>   - 평균과 최악 모두 시간 복잡도는 O(dn)
