## 2023년 5월 기출문제

#### 31. 명세 기반 테스트 중 올바른 테스트 기법
> - Equivalence Partitioning Testing(동시 분할 검사)
>   - `프로그램의 입력 조건에 중점`을 두고, 어느 하나의 입력 조건에 대하여 타당한 값과 그렇지 못한 값을 설정하여 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 테스트 기법
>   - 경험과 필요에 따라 하나 이상의 값을 선정하여 TC를 작성하는 경우, 결과적으로 보장성은 동일
>   - 명세에 있는 입/출력 값을 활용하기 때문에 명세기반 테스트 기법임(구조기반, 경험기반 기법도 적용 가능)
> - Cause-Effect Graph Testing(원인-결과 그래프 검사)
>   - 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
> - Boundary Value Analysis(경계값 분석)
>   - 입력 자료에만 치중한 동치 분할 기법을 보완하기 위한 기법. 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법
> - Comparison Testing(비교 검사)
>   - 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법

#### 32. 내·외부 모듈 간 인터페이스 데이터 표준을 확인하는데 사용되는 정보
> - 인터페이스 데이터 표준은 `인터페이스 기능`과 `데이터 인터페이스`를 통해 확인할 수 있음

#### 34. 다음 설명하는 정렬(Sort)
> 틀린 문제 : 퀵 정렬에 대한 설명
> - **퀵 정렬(Quick Sort)**
>   - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법
>   - 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬
>   - 피봇(pivot)을 사용하며, 회악의 경우 n(n-1)/2회의 비교를 수행해야함

> #### 정렬(sort)의 종류
> ###### 1. 삽입 정렬(Insertion Sort)
> - 삽입 정렬은 가장 간단한 정렬 방식으로 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬함
> - 평균과 최악 모두 수행 시간 복잡도는 O(n^2)
> ###### 2. 쉘 정렬(Shell Sort)
> - 삽입 정렬을 확장한 개념으로 입력 파일을 어떤 매개변수(h)의 값으로 서브파일을 구성하고, 각 서브파일을 삽입 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식
> - 평균 수행 시간 복잡도는 O(n^1.5)이고, 최악의 수행 시간 복잡도는 O(n^2)
> ###### 3. 선택 정렬(Selection Sort)
> - n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식
> - 평균과 최악 모두 수행 시간 복잡도는 O(n^2)
> ###### 4. 버블 정렬(Bubble Sort)
>   - 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식
>   - 계속 정렬 여부를 플래그 비트(f)로 결정
>   - 평균과 최악 모두 수행 시간 복잡도는 O(n^2)
> ###### 5. 퀵 정렬(Quick Sort)
>   - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는 방식으로 정렬함
>   - 위치에 관계없이 임의의 키를 분할 원소로 사용할 수 있음
>   - 정렬 방식 중에서 가장 빠른 방식
>   - 프로그램에서 되부름을 이용하기 때문에 스택(Stack)이 필요
>   - 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬
>      - 분할(Divide): 기준값인 피봇(Pivot)을 중심으로 정렬할 자료들을 2개의 부분집합으로 나눔
>      - 정복(Conquer): 부분집합의 원소들 중 피봇(Pivot)보다 작은 원소들은 왼쪽, 피봇(Pivot)보다 큰 원소들은 오른쪽 부분집합으로 정렬
>      - 부분집합의 크기가 더 이상 나누어질 수 없을 때까지 분할과 정복을 반복 수행
>   - 평균 수행 시간 복잡도는 O(nlog2n)이고, 최악의 수행 시간 복잡도는 O(n^2)
> ###### 6. 힙 정렬(Heap Sort)
> - 큰 키(우선 순위)에 자주 액세스하거나 키(우선 순위) 중심으로 정렬된 시퀀스를 활용해야 할 때 유용한 자료구조
> - 완전이진트리(전이진 트리, complete binary tree)를 이용한 정렬 방식
> - 평균과 최악 모두 시간 복잡도는 O(nlog2n) 
> ###### 7. 2-Way 합병 정렬(Merge Sort)
> - 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식
> - 평균과 최악 모두 시간 복잡도는 O(nlog2n)
> ###### 8. 기수 정렬(Radix Sort, Bucket Sort)
> - Queue를 이용하여 자릿수(Digit)별로 정렬하는 방식.
> - 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬함.
> - 평균과 최악 모두 시간 복잡도는 O(dn)

#### 35. 자료 구성 단위에 대한 설명으로 옳지 않은 것
> ###### 비트(Bit)
> - 자료(정보) 표현의 최소 단위
> - 두 가지 상태(0과 1)를 표시하는 2진수 1자리임
> ###### 니블(Nibble)
> - 4개의 비트(Bit)가 모여 1개의 니블(Nibble)을 구성함
> - 16진수 1자리를 표현하기에 적합함
> ###### 바이트(Byte)
> - 문자를 표현하는 최소 단위
> - 8개의 비트(Bit)가 모여 1바이트(Byte)를 구성함
> ###### 워드(Word)
> - CPU가 한 번에 처리할 수 있는 명령 단위
> ###### 필드(Field)
> - 파일 구성의 최소 단위
> - 의미 있는 정보를 표현하는 최소 단위
> ###### 레코드(Record)
> - 하나 이상의 관련된 필드가 모여서 구성됨
> ###### 블록(Block)
> - 하나 이상의 논리 레코드가 모여서 구성됨
> ###### 파일(File)
> - 프로그램 구성의 기본 단위로, 여러 레코드가 모여서 구성됨
> ###### 데이터베이스(Database)
> - 여러 개의 관련된 파일(File)의 집합

#### 37. 위험 관리의 일반적인 절차로 적합한 것
> `위험 식별` → `위험 분석 및 평가` → `위험 관리 계획` → `위험 감시 및 조치`

#### 40. 단위 테스트(Unit Test)를 통해 발견할 수 있는 오류
> - 모듈이나 컴포넌트 단위로 기능을 확인하는 테스트
> - 모듈 간의 비정상적 상호 작용 오류 검사를 위해서는 통합 테스트를 수행해야 함
> - 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초첨을 맞춰 테스트하는 것
> - 단위 테스트에는 인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사함
> - 단위 테스트는 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행
> - 단위 테스트는 구조 기반 테스트와 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행
>   - 구조 기반 테스트	: 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트 시행	제어 흐름, 조건 결정
>   - 명세 기반 테스트	: 목적 및 실행 코드 기반의 블랙박스 테스트 시행	동등 분할, 경계 값 분석
> - 단위 테스트로 발견 가능한 오류: `알고리즘 오류에 따른 원치 않는 결과`, `탈출구가 없는 반복문의 사용`, `틀린 계산 수식에 의한 잘못된 결과`
