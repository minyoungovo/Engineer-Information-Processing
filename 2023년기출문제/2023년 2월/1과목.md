### 2023년 2월


#### 1과목

### UML 다이어그램(Unified Modeling Language)이 아닌 것
##### 틀린 부분
1. 액티비티 다이어그램(Activity Diagram)
2. **절차 다이어그램(Procedural Diagram) (X)**
3. 클래스 다이어그램(Class Diagram)
4. 시퀀스 다이어그램(Sequence Diagram)

#

### 비기능 요구사항
> ##### `성능`에 관한 비기능 요구사항
- 처리속도 및 시간, 처리량 등의 성능에 대한 요구사항
- **"차량 대여 시스템에서 제공하는 모든 화면은 3초안에 사용자에게 보여줘야한다"**
  
> ##### `보안`에 관한 비기능 요구사항
- 보안 및 접근 통제를 위한 요구사항

#

### 자료 흐름도(DFD) 작성 지침

<details>
<summary>자료 흐름도 구성 요소(접기/펼치기)</summary>
  
<!-- summary 아래 한칸 공백 두어야함 -->
> ##### 자료 흐름도 구성 요소
- 프로세스(Process)
  - 자료를 변환시키는 시스템의 한 부분(처리 과정)을 나타내며 처리, 기능, 변환, 버블이라고도 함
  - 원이나 둥근 사각형으로 표시하고 그 안에 프로세스 이름을 기입함
- 자료 흐름(Data Flow)
  -  자료의 이동(흐름)이나 연관관계를 나타냄
  -  화살표 위에 자료의 이름을 기입함
- 자료 저장소(Data Store)
  - 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타냄
  - 도형(평행선) 안에 자료 저장소 이름을 기입함
- 단말(Terminator)
  - 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음(정보의 생산자와 소비자)
  - 도형(사각형) 안에 이름을 기입함
</details>
 
##### 틀린 부분
> - **자료 흐름은 처리(Process)를 거쳐 변환될 때마다 새로운 이름을 부여한다. (O)** <br/>
> - **자료 저장소에 입력 화살표가 있으면 반드시 출력 화살표도 표시되어야 한다. (X)** <br/>
>  자료 저장소의 입력 화살표는 `데이터 입력 및 수정`을 의미하는 것

#

### 활동 다이어그램(Activity Diagram)에 대한 설명
> 오퍼레이션이나 처리 과정이 수행되는 동안 일어나는 일들을 `단계적으로 표현`한 다이어그램

##### 틀린 부분
> - `클래스 다이어그램(Class Diagram)` : 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 다이어그램
> - `순차 다이어그램(Sequence Diagram)` : `상호 작용하는 시스템`이나 `객체들이 주고 받는 메시지`를 표현하는 다이어그램
> - `상태 다이어그램(State Diagram)` : 하나의 객체가 자신이 속한 클래스의 `상태 변화` 혹은 다른 객체와의 `상호 작용`에 따라 상태가 어떻게 변하는지를 표현하는 다이어그램

#

### 객체지향 설계 원칙(SOLID 원칙)
> 시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 5가지 원칙
>  5가지 원칙의 앞 글자를 따 `SOLID 원칙`이라고도 불림

##### 틀린 부분
> - 인터페이스 통합 원칙(IIP: Interface Integration Principle) (X) 
> - **인터페이스 분리 법칙(ISP; Interface Segregation Principle) (O)**

<details>
<summary>인터페이스 분리 법칙 종류(접기/펼치기)</summary>
  
<!-- summary 아래 한칸 공백 두어야함 -->

#### 단일 책임 원칙(SRP; Single Responsibility Principle) - S
- 객체는 단 하나의 책임만 가져야 한다
- `응집도는 높고, `결합도는 낮게` 설계하는 것

##### 개방-폐쇄 원칙(OCP; Open-Closed Principle) - O
- 기존의 코드를 변경하지 않고 기능 추가할 수 있도록 설계해야 한다는 원칙
- 공통 인터페이스를 하나의 인터페이스로 묶어 `캡슐화`하는 방법이 대표적

##### 리스코프 치환 워칙(LSP; Liskov Substitution Principle) - L
- 자식  클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
- 자식 클래스는 부모 클래스의 책임 무시하거나 재정의하지 않고 `확장`만 수행하도록 해야 함
  
##### 인터페이스 분리 원칙(ISP; Interface Segregation Principle) - I
- 자신이 사용하지 않는 인터페이스와 `의존 관계`를 맺거나 `영향 받지 않아야` 한다는 원칙
- 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙은 `인터페이스가 갖는 하나의 책임`

##### 의존 역전 원칙(DIP; Dependency Inversion Principle) - D
- 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 `추상성이 높은 클래스와 의존 관계`를 맺어야 한다는 점
- 일반적으로 인터페이스를 활용하면 이 원칙은 준수됨
</details>

#

#### 결합도(Coupling)단계를 약한 순서에서 강한 순서로
> `Data` → `Stamp` → `Control` → `Common` → `Content` <br/>
>  자료 → 스탬프 → 제어 → 외부(External) → 공통 → 내용

<details>
<summary>결합도(Coupling) 종류(접기/펼치기)</summary>

<!-- summary 아래 한칸 공백 두어야함 -->

##### Data Coupling (자료 결합도)
- 모듈들이 parameter 등을 통해 데이터를 공유하는 경우
- 각 데이터가 기본적인 것(elementary piece)이고, 그 데이터를 공유하는 유일한 데이터이어야 한다.(제곱근을 계산하는 함수로 하나의 정수를 전달하는 경우)

##### Stamp Coupling (data-structured coupling) (스탬프 결합도)
- 모듈들이 데이터 구조를 공유하고, 그 서로 다른 일부만을 사용하는 경우
- 접근할 필요가 없는 필드만 수정되는 경우에도, 레코드/필드를 읽는 방법을 변경해야 한다.(데이터의 배치가 변경되기 때문)

##### Control Coupling (제어 결합도)
- 하나의 모듈이 다른 모듈로 무엇을 해야 하는지에 대한 정보를 넘겨줌으로써 다른 모듈의 흐름을 제어

##### External Coupling (외부 결합도)
- 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 디바이스 인터페이스를 공유할 때 발생.(SW 외부환경과 연관되어 있음)
- 기본적으로 외부 툴이나 디바이스와의 통신과 관련이 있다.

##### Common Coupling (공통 결합도)
- 두 개의 모듈이 같은 글로벌 데이터를 공유하는 상태. (전역 변수)
- 공유 자원(변수)을 변경하면 그 자원을 사용하는 모든 모듈의 변경이 필요하다.

##### Content Coupling (내용 결합도)
- 하나의 모듈이 다른 모듈의 내부 동작을 수정하거나 내부 동작에 의존하는 상태. _내부 자료나 제어 정보를 사용하는 것_
- 한 모듈이 데이터를 생성하는 방법을 변경하면, 다른 모듈의 변경이 필요하다. (다른 모듈이 로컬 데이터에 접근하는 경우)

##### Message Coupling (메시지 결합도)
- 가장 낮은 결합도 단계. 분산 및 메시지 전달로 실현 (decentralization & message passing)
- (의존성 주입 / dependency injection, Observable)

</details>

#

### GoF(Gangs of Four) 디자인 패턴에 대한 설명
##### 틀린 부분
- `Factory Method Pattern`은 상위클래스에서 객체를 생성하는 인터페이스를 정의. 하위클래스에서 인스턴스를 생성하도록 하는 방식
- `Prototype Pattern`은 Prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구죠
- **`Bridge Pattern`은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할(X) - 어댑터(Aapter) 패턴**
- `Mediator Pattern`은 객체간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해줌

<details>
<summary>GoF(Gangs of Four) 디자인 패턴(접기/펼치기)</summary>
  
<!-- summary 아래 한칸 공백 두어야함 -->
#### 디자인 패턴 GoF(Gang of Four)
> - 디자인패턴은 자주 발생하는 문제를 해결하기 위한 반복적 해결 방법
> - 주로 어떤 패턴에 어떤게 속하는지 나온다. 간단하게 무슨 패턴인지 알아두면 베스트

##### 생성 패턴
  - 추상 팩토리(Abstract Factory) : 연관 객체 그룹 생성 후 추상적 표현
  - 빌더(Builder) : 조립, 객체 생성
  - 팩토리메서드(Factory Method) : 객체 생성을 서브클래스에서 결정해서 생성
  - 프로토타입(Prototype) : 원본 객체 복제해서 생성
  - 싱글톤(Singleton) : 필요시 하나의 객체만 생성할 수 있게(DB연결 등)
※ 팩토리, 빌더가 나오면 일단 생성이다.

##### 구조 패턴
  - 어댑터(Adaptor) : 비호환 인터페이스에 호환성 부여할 수 있는 구조로 구성
  - 브릿지(Bringe) : 독립적 확장이 가능하게 구조 구성. ※ 서로 연결하는 역할이 아니다.
  - 컴포지트(Composite) : 복합, 단일 객체 구분없이 사용할 수 있게 구조 구성
  - 데코레이터(Decorator) : 상속 없이 확장할 수 있는 구조 구성
  - 퍼사드(Facade) : 상위 인터페이스 구성 후 서브클래스 기능 사용할 수 있게 구조 구성
  - 플라이웨잇(Flyweight) : 인스턴스 공유 및 메모리 절약할 수 있게 구조 구성
  - 프록시(Proxy) : 접근이 힘든 객체를 연결하는 인터페이스 역할할 수 있게 구조 구성

##### 행위 패턴
  - 메멘토(Memento)
  - 옵저버(Observer)
  - 상태(State)
  - 전략(Strategy)
  - 템플릿(Template Method)
  - Chain of Reponsibility
  - Command
  - Interpreter
  - Iterator
  - Mediator
  - Visitor

###### <a href="https://codingdodo.tistory.com/78">출처 : https://codingdodo.tistory.com/78</a>
</details>
